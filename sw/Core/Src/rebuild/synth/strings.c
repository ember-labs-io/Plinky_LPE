#include "strings.h"
#include "data/tables.h"
#include "hardware/adc_dac.h"
#include "hardware/midi.h"
#include "hardware/midi_defs.h"
#include "hardware/touchstrips.h"
#include "pitch_tools.h"
#include "ui/pad_actions.h"
#include "ui/shift_states.h"
#include "ui/ui.h"

extern bool read_from_seq;
extern s8 cur_step;
extern bool recording;
extern Preset rampreset;
extern PatternQuarter rampattern[4];
extern u8 rampattern_idx;
extern u8 cur_pattern;
extern u32 ramtime[GEN_LAST];
extern euclid_state seq_rhythm;
bool isplaying(void);
void set_cur_step(u8 newcurstep, bool triggerit);
int calcseqsubstep(int tick_offset, int maxsubsteps);
FingerRecord* readpattern(int string_id);
int param_eval_finger(u8 paramidx, int fingeridx, Touch* f);
// -- needs cleaning up

// current frame in string_touch
static u8 strings_write_frame;
static u8 strings_read_frame;

// a string_touch is a virtual touch, it can be generated by a physical touch, latching, arp and sequencer
//
// pointers to this array should always be marked with an s-prefix (s_touch) to differentiate them from pointers named
// "touch", which refer to a physical touch read from the touchstrips
static Touch string_touch[NUM_STRINGS][NUM_TOUCH_FRAMES];

// the same array as above, but sorted by pitch
static Touch string_touch_sorted[NUM_STRINGS][NUM_TOUCH_FRAMES];

// bitmasks that keep track of touches on the read_frame, implements hysteresis
u8 string_touched = 0;
static u8 string_touched_1back = 0;
u8 string_touch_start = 0;

// bitmasks of touches during the write_frame, used for arp and latch checking
static u8 write_string_touched;
u8 write_string_touched_copy = 0; // direct copy of the above
u8 write_string_touched_1back = 0;
static u8 strings_phys_touched = 0;

// pressure
static s32 total_string_pressure = 0;
static s32 total_string_pressure_1back = 0;
static s32 total_string_pressure_2back = 0;

// midi
u8 midi_note[NUM_STRINGS];
static u8 midi_velocity[NUM_STRINGS];
static u8 midi_poly_pressure[NUM_STRINGS];
static u16 midi_position[NUM_STRINGS]; // for pulsing leds at note position
u8 midi_channel[NUM_STRINGS] = {255, 255, 255, 255, 255, 255, 255, 255};
u8 midi_pressure_override = 0; // true if midi note is pressed
u8 midi_pitch_override = 0;    // true if midi note is sounded out, includes release phase
u8 midi_suppress = 0;          // true if midi is suppressed by touch / latch / seq

// rj: this is a general tool, but it's only used to generate random touch variations from TouchMemCompressed - we might
// look at saving uncompressed touches, which would make rand_range redundant
static int rand_range(int mn, int mx) {
	return mn + (((rand() & 255) * (mx - mn)) >> 8);
}

// latching

typedef struct TouchMemCompressed {
	u8 pos;
	u8 pres;
} TouchMemCompressed;

static TouchMemCompressed latch_touch[8];

void clear_latch(void) {
	memset(latch_touch, 0, sizeof(latch_touch));
}
static inline u8 pres_compress(s16 pressure) {
	return clampi((pressure + 12) / 24, 0, 255);
}
static inline u16 pres_decompress(u8 pressure) {
	return maxi(rand_range(24 * pressure - 12, 24 * pressure + 12), 0);
}
static inline u8 pos_compress(u16 position) {
	return clampi((position + 4) / 8, 0, 255);
}
static inline u16 pos_decompress(u8 position) {
	return maxi(rand_range(8 * position - 4, 8 * position + 4), 0);
}

// -- latching

// this only exists for midi output - remove after midi cleanup
Touch* get_string_touch_prev(u8 string_id, u8 frames_back) {
	return &string_touch[string_id][(strings_write_frame - frames_back) & 7];
}

Touch* get_string_touch(u8 string_id) {
	return &string_touch[string_id][strings_read_frame];
}

Touch* sorted_string_touch_ptr(u8 string_id) {
	return &string_touch_sorted[string_id][0];
}

// this combines inputs from touchstrips, latch, arp & sequencer, and saves the resulting Touch in
// string_touch[string_id]
static void generate_string_touch(u8 string_id) {
	static u8 last_edited_step_global = 255;
	static u8 last_edited_substep_global = 255;
	static u8 last_edited_step[8] = {255, 255, 255, 255, 255, 255, 255, 255};
	static int record_to_substep;
	static bool suppress_latch = false;
	// helpers
	u8 mask = 1 << string_id;
	bool is_read = touch_read_this_frame(string_id);
	s16 pres_2back =
	    get_touch_prev(string_id, is_read ? 2 : 3)->pres; // this is because we only update every other frame?
	u8 sub_step = calcseqsubstep(0, 8);
	bool pres_increasing;
	// fundamental
	Touch* touch = get_touch_prev(string_id, is_read ? 0 : 1); // the touch we're processing
	Touch* s_touch =
	    &string_touch[string_id][strings_write_frame]; // the string-touch that results from that processing
	s16 pressure = TOUCH_MIN_PRES; // we save the resulting pressure in here until we write it to s_touch
	s16 position = TOUCH_MIN_POS;  // we save the resulting position in here until we write it to s_touch

	// === TOUCH INPUT === //

	if (strip_available_for_synth(string_id) || ui_mode == UI_SAMPLE_EDIT) {
		// read touch values
		pressure = touch->pres;
		position = touch->pos;
		pres_increasing = pressure > pres_2back;
		// log touch
		if (pressure > 0)
			strings_phys_touched |= mask;
		else
			strings_phys_touched &= ~mask;

		// === LATCH WRITE === //

		// finger touching and pressure increasing
		if ((rampreset.flags & FLAGS_LATCH) && pressure > 0 && pres_increasing) {
			// is this a new touch after no fingers where touching?
			if (pres_2back <= 0 && strings_phys_touched == mask) {
				// start a new latch, clear all previous latch values
				for (u8 i = 0; i < NUM_STRINGS; i++) {
					latch_touch[i].pres = 0;
					latch_touch[i].pos = 0;
				}
				// in step record mode, trying to start a new latch temporarily turns off latching
				// trying to start a new latch outside of step record mode turns it on again
				suppress_latch = recording && !isplaying();
			}
			// save latch values
			if (!suppress_latch) {
				latch_touch[string_id].pres = pres_compress(pressure);
				latch_touch[string_id].pos = pos_compress(position);
			}
			// RJ: I could not work out a way to work with average values that wasn't
			// sluggish or gave undesired intermediate values - slides and in-between notes
			// Current solution is just saving one value and randomizing when reading it out
			// Result feels great, but good to reconsider when the exact contents of
			// touchstrip and string_touch are more clear

			// Averaging code for reference:
			//
			// u8 max_pos = 0, min_pos = 255, maxpressure = 0;
			// Touch* f = string_touch[string_id];
			// for (int j = 0; j < 8; ++j, ++f) {
			// 	u8 p = clampi((f->pos + 4) / 8, 0, 255);
			// 	min_pos = mini(p, min_pos);
			// 	max_pos = maxi(p, max_pos);
			// 	u8 pr = clampi(f->pres / 12, 0, 255);
			// 	maxpressure = maxi(maxpressure, pr);
			// }
			// latch[string_id].pres = maxpressure;
			// latch[string_id].min_pos = min_pos;
			// latch[string_id].max_pos = max_pos;
		}
	}

	// === LATCH RECALL === //

	// latch pressure larger than touch pressure
	if ((rampreset.flags & FLAGS_LATCH) && latch_touch[string_id].pres > 0
	    && latch_touch[string_id].pres * 24 > pressure) {
		// recall latch values
		pressure = pres_decompress(latch_touch[string_id].pres);
		position = pos_decompress(latch_touch[string_id].pos);

		// signal sequencer it's okay to record this
		pres_increasing = true;

		// Averaging code for reference:
		//
		// int min_pos = latch[string_id].min_pos * 8 + 2;
		// int max_pos = latch[string_id].max_pos * 8 + 6;
		// int avgpos = (min_pos + max_pos) / 2;
		// int range = (max_pos - min_pos) / 4;
		// pressure = latchpres ? rand_range(latchpres - 12, latchpres) : -1024;
		// position = rand_range(avgpos-range,avgpos+range);
	}

	// === SEQ RECORDING === //

	// RJ: because of the way data is stored in the sequencer, it is currently not possible to record
	// midi data into it without imposing some serious restrictions on the range of midi notes that
	// can be played. So we're only doing this for touches for now

	u8 seq_quarter = (cur_step >> 4) & 3;
	FingerRecord* seq_record = &rampattern[seq_quarter].steps[cur_step & 15][string_id];
	bool data_saved = false;
	// We're recording into the loaded pattern
	if (recording && rampattern_idx == cur_pattern) {
		// holding clear sets the pressure to zero, which will effectively clear the sequencer at this point
		u8 seq_pres = shift_state == SS_CLEAR ? 0 : pres_compress(pressure);
		u8 seq_pos = shift_state == SS_CLEAR ? 0 : pos_compress(position);

		// holding a note or clearing during playback
		if ((seq_pres > 0 && pres_increasing) || shift_state == SS_CLEAR) {
			// live recording
			if (isplaying()) {
				record_to_substep = sub_step;
			}
			// step recording
			else {
				// editing a new step, and waited for sub_step to reset to zero
				if (cur_step != last_edited_step_global && sub_step == 0) {
					// we have not edited any sub_step
					last_edited_substep_global = 255;
					// we have not edited this step for any finger
					memset(last_edited_step, 255, sizeof(last_edited_step));
					// start at sub_step 0
					record_to_substep = 0;
					// this skips the first increment of record_to_substep, right below
					last_edited_substep_global = 0;
					// we're now editing the current step
					last_edited_step_global = cur_step;
				}
				// editing a new sub_step
				if (sub_step != last_edited_substep_global) {
					// are we in the step?
					if (record_to_substep < 8) {
						// move one sub_step forward
						record_to_substep++;
					}
					// are we at the end of the step?
					else {
						// push all data one sub_step backward
						for (u8 i = 0; i < 7; i++) {
							seq_record->pres[i] = seq_record->pres[i + 1];
							if (!(sub_step & 1) && !(i & 1))
								seq_record->pos[i / 2] = seq_record->pos[i / 2 + 1];
						}
					}
					last_edited_substep_global = sub_step;
				}
				// first finger edit on this step
				if (cur_step != last_edited_step[string_id]) {
					// clear the step for this finger
					memset(seq_record->pres, 0, sizeof(seq_record->pres));
					memset(seq_record->pos, 0, sizeof(seq_record->pos));
					// we're now editing this step with this finger
					last_edited_step[string_id] = cur_step;
				}
			}
			// record!
			seq_record->pres[mini(record_to_substep, 7)] = seq_pres;
			seq_record->pos[mini(record_to_substep, 7) / 2] = seq_pos;
			data_saved = true;
		}
		if (data_saved)
			ramtime[GEN_PAT0 + seq_quarter] = millis();
	}
	// not recording
	else {
		// clear this for next recording
		last_edited_step_global = 255;
	}

	// === SEQ PLAYING === //

	// no pressure generated by touch or latch and sequencer wants to play
	if (pressure <= 0 && (isplaying() || seq_rhythm.did_a_retrig)) {
		FingerRecord* seq_record = readpattern(string_id);
		if (seq_record) {
			int gatelen = param_eval_finger(P_GATE_LENGTH, string_id, s_touch) >> 8;
			int small_substep = calcseqsubstep(0, 256);
			if (seq_record->pres[sub_step] && !seq_rhythm.supress && small_substep <= gatelen
			    && shift_state != SS_CLEAR) {
				read_from_seq = true;
				pressure = pres_decompress(seq_record->pres[sub_step]);
				position = pos_decompress(seq_record->pos[sub_step / 2]);
			}
		}
	}

	// === MIDI INPUT === //

	// midi gets suppressed if touch, latch or sequencer generate pressure
	if (pressure > 0)
		midi_suppress |= mask;
	else
		midi_suppress &= ~mask;
	// a midi note is playing this string
	if ((midi_pressure_override & mask) && !(midi_suppress & mask)) {
		// take pressure and position from midi data
		pressure = 1
		           + (midi_velocity[string_id]
		              + maxi(midi_poly_pressure[string_id], midi_chan_pressure[midi_channel[string_id]]))
		                 * 16;
		// for midi, position only defines where the leds light up on the string
		position = midi_position[string_id];
	}

	// === CV GATE === //

	// scale pressure with cv gate input
	pressure = pressure * adc_get_smooth(ADC_S_GATE);

	// === FINISHING UP === //

	// save input results to global variables to be used by other code
	s_touch->pres = pressure;
	s_touch->pos = position;
	total_string_pressure += maxi(0, s_touch->pres);
	if (s_touch->pres > 0) {
		write_string_touched |= mask;
	}
	else {
		write_string_touched &= ~mask;
	}

	// new finger touch, slightly randomize touch-values in history to avoid static touch values
	static s16 pres_1back[8];
	if (pres_1back[string_id] <= 0 && s_touch->pres > 0) {
		Touch* st = string_touch[string_id];
		int new_pres = s_touch->pos;
		for (int h = 0; h < 8; ++h, st++) {
			if (h != strings_write_frame) {
				if (st->pres <= 0) {
					st->pos = (st->pos & 3) ^ new_pres;
				}
			}
		}
	}
	pres_1back[string_id] = s_touch->pres;

	// sort string's frames by position
	sort8((int*)string_touch_sorted[string_id], (int*)string_touch[string_id]);
}

// manage generating the string_touch array
void generate_string_touches(void) {
	static bool do_second_half = false;

	// start of a full update of all strings
	if (!do_second_half) {
		total_string_pressure = 0;
		read_from_seq = false;
	}
	// update half of the strings (0 - 3 / 4 - 7)
	for (u8 string_id = 0; string_id < NUM_STRINGS / 2; ++string_id)
		generate_string_touch(string_id + do_second_half * NUM_STRINGS / 2);
	// end of a full update of all strings
	if (do_second_half) {
		// you've released your fingers, you're recording in step mode - let's advance!
		if (total_string_pressure <= 0 && total_string_pressure_1back <= 0 && total_string_pressure_2back > 0
		    && recording && !isplaying()) {
			// this probably belongs in sequencer
			set_cur_step(cur_step + 1, false);
		}
		// backup two frames of total pressure
		total_string_pressure_2back = total_string_pressure_1back;
		total_string_pressure_1back = total_string_pressure;

		// processing the strings happens at a significantly higher framerate than reading out the touchstrips
		// u8 touch_frame tracks which frame in the touches array is currently being written to
		// u8 strings_write_frame tracks which frame in the string_touch array we are writing to
		// we never want any half-filled frames in the string_touch array, so we only update strings_write_frame after
		// processing a full frame of strings
		//
		// in practice, all internal functionality (arp, sequencer, mod sources, etc) get processed at the higher
		// framerate - whenever touchstrips.h has read out a full frame of touches, strings_write_frame increments to
		// make use of the new touch-data
		if (strings_write_frame != touch_frame) {
			// we read from the frame that was written just before
			strings_read_frame = strings_write_frame;
			// we write to the frame that is currently being processed by the touchstrips
			strings_write_frame = touch_frame;
		}
	}
	// toggle which half we process
	do_second_half = !do_second_half;

	string_touched_1back = string_touched;
	string_touched = 0;
	for (u8 string_id = 0; string_id < NUM_STRINGS; ++string_id) {
		Touch* s_touch = get_string_touch(string_id);
		s8 thresh = (string_touched_1back & (1 << string_id)) ? -50 : 1; // hysteresis
		if (s_touch->pres > thresh) {
			string_touched |= 1 << string_id;
		}
	}
	string_touch_start = (string_touched & ~string_touched_1back);

	write_string_touched_1back = write_string_touched_copy;
	write_string_touched_copy = write_string_touched;
}

// == MIDI == //

static u8 find_midi_note_string(u8 chan, u8 note) {
	for (int string_id = 0; string_id < 8; ++string_id)
		if ((midi_pitch_override & (1 << string_id)) && midi_note[string_id] == note && midi_channel[string_id] == chan)
			return string_id;
	return 255;
}

static u8 find_string_for_midi_pitch(int midi_pitch) {
	// pitch falls below center of bottom string
	if (midi_pitch < string_center_pitch(0))
		return 0;
	// pitch falls above center of top string
	if (midi_pitch >= string_center_pitch(7))
		return 7;
	// find the string with the closest center pitch
	u8 desired_string = 0;
	s32 min_dist = 2147483647; // int max
	for (u8 i = 0; i < 8; i++) {
		u32 pitch_dist = abs(string_center_pitch(i) - midi_pitch);
		if (pitch_dist < min_dist) {
			min_dist = pitch_dist;
			desired_string = i;
		}
	}
	return desired_string;
}

// return the position of the highest pad the midi pitch is higher than - or equal to
static u16 find_string_position_for_midi_pitch(u8 string_id, int midi_pitch) {
	// top pad has pad_y 0
	// pad spacing is 256 per pad, position = pad_y << 8
	for (u8 pad = 7; pad > 0; pad--) {
		if (midi_pitch >= string_pitch_at_pad(string_id, pad)) {
			return (7 - pad) << 8;
		}
	}
	// if the pitch was lower than the pitch of pad 1, we return the bottom pad
	return 7 << 8;
}

static u8 find_free_midi_string(u8 midi_note_number, u16* midi_note_position, u8 chan) {
	Touch* s_touch = get_string_touch(0);
	s32 midi_pitch = 12 *
	                     // pitch from octave parameter
	                     ((param_eval_finger(P_OCT, 0, s_touch) << 9)
	                      // pitch from pitch parameter
	                      + (param_eval_finger(P_PITCH, 0, s_touch) >> 7))
	                 // pitch from midi note
	                 + midi_note_to_pitch_offset(midi_note_number, chan);

	// find the best string for this midi note
	u8 desired_string = find_string_for_midi_pitch(midi_pitch);

	// try to find:
	// 1. the non-pressed, non-sounding string closest to our desired string
	// 2. the non-pressed string that is the quietest
	u8 string_option[8];
	u8 num_string_options = 0;
	u8 min_string_dist = 255;
	float min_vol = __FLT_MAX__;
	u8 min_string_id = 255;

	// collect non-pressed, non-sounding strings
	for (u8 string_id = 0; string_id < 8; string_id++) {
		if (!(midi_pressure_override & (1 << string_id)) && !(write_string_touched & (1 << string_id))
		    && voices[string_id].env1_lvl < 0.001f) {
			string_option[num_string_options] = string_id;
			num_string_options++;
		}
	}
	// find closest
	for (u8 option_id = 0; option_id < num_string_options; option_id++) {
		if (abs(string_option[option_id] - desired_string) < min_string_dist) {
			min_string_dist = abs(string_option[option_id] - desired_string);
			min_string_id = string_option[option_id];
		}
	}
	// return closest, if found
	if (min_string_dist != 255) {
		// collect the position on the string before returning
		*midi_note_position = find_string_position_for_midi_pitch(min_string_id, midi_pitch);
		return min_string_id;
	}
	// collect non-pressed strings
	num_string_options = 0;
	for (u8 string_id = 0; string_id < 8; string_id++) {
		if (!(midi_pressure_override & (1 << string_id)) && !(write_string_touched & (1 << string_id))) {
			string_option[num_string_options] = string_id;
			num_string_options++;
		}
	}
	// find quietest
	for (u8 option_id = 0; option_id < num_string_options; option_id++) {
		if (voices[string_option[option_id]].env1_lvl < min_vol) {
			min_vol = voices[string_option[option_id]].env1_lvl;
			min_string_id = string_option[option_id];
		}
	}
	// collect the position on the string before returning
	if (min_string_id != 255) {
		*midi_note_position = find_string_position_for_midi_pitch(min_string_id, midi_pitch);
	}
	// return quietest - this returns 255 if nothing was found
	return min_string_id;
}

void strings_rcv_midi(u8 status, u8 d1, u8 d2) {
	u8 chan = status & 0x0F; // save the channel
	u8 type = status & 0xF0; // take the channel out

	switch (type) {
	case MIDI_NOTE_OFF: {
		// find string with existing midi note
		u8 string_id = find_midi_note_string(chan, d1);
		if (string_id < NUM_STRINGS) {
			// deactivate midi for string
			midi_pressure_override &= ~(1 << string_id);
		}
	} break;
	case MIDI_NOTE_ON: {
		u16 note_position;
		// find string with existing midi note
		u8 string_id = find_midi_note_string(chan, d1);
		// none found - find empty string
		if (string_id == 255) {
			string_id = find_free_midi_string(d1, &note_position, chan);
			if (string_id < NUM_STRINGS)
				midi_position[string_id] = note_position;
		}
		if (string_id < NUM_STRINGS) {
			// save in string
			midi_note[string_id] = d1;
			midi_channel[string_id] = chan;
			midi_velocity[string_id] = d2;
			midi_poly_pressure[string_id] = 0;
			// activate midi for string
			midi_pressure_override |= 1 << string_id;
			midi_pitch_override |= 1 << string_id;
		}
	} break;
	case MIDI_POLY_KEY_PRESSURE: {
		u8 string_id = find_midi_note_string(chan, d1);
		if (string_id < NUM_STRINGS) {
			midi_poly_pressure[string_id] = d2;
		}
	} break;
	}
}

void strings_clear_midi(void) {
	midi_pressure_override = 0;
	midi_pitch_override = 0;
	memset(midi_note, 0, sizeof(midi_note));
	memset(midi_velocity, 0, sizeof(midi_velocity));
	memset(midi_poly_pressure, 0, sizeof(midi_poly_pressure));
	memset(midi_channel, 255, sizeof(midi_channel));
}
